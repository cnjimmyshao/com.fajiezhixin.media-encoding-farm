extends layout

block content
  h2 新建任务
  form(id="job-form")
    label(for="inputPath") 输入文件绝对路径
    input(type="text", id="inputPath", name="inputPath", required)

    label(for="outputPath") 输出文件绝对路径
    input(type="text", id="outputPath", name="outputPath", required)

    fieldset
      legend 编码格式
      div(id="codecOptions", class="radio-group")
        each codec, index in codecOptions
          label(class="radio-option")
            input(type="radio", name="codec", value=codec.key, required=index === 0, checked=index === 0)
            span= codec.label

    fieldset
      legend 编码器
      div(id="encoderOptions", class="radio-group")
        p(class="radio-placeholder") 请选择编码器

    fieldset
      legend 输出分辨率
      div(id="scaleOptions", class="radio-group")
        each scale, index in resolutionOptions
          label(class="radio-option")
            input(type="radio", name="scale", value=scale.key, required=index === 0, checked=index === 0)
            span= scale.label

    fieldset
      legend 质量控制模式
      div(id="qualityModeOptions", class="radio-group")
        label(class="radio-option")
          input(type="radio", name="qualityMode", value="crf", checked, required)
          span CRF（恒定质量）
        label(class="radio-option")
          input(type="radio", name="qualityMode", value="bitrate")
          span 码率（恒定带宽）

    fieldset(id="crfFieldset")
      legend CRF 目标
      div(id="crfOptions", class="radio-group")
        p(class="radio-placeholder") 请选择 CRF 值

    fieldset(id="bitrateFieldset", class="hidden")
      legend 目标码率（Kbps）
      input(type="number", id="bitrateKbps", name="bitrateKbps", min="100", step="50", placeholder="例如 3500")

    fieldset
      legend 编码 Profile
      div(id="profileOptions", class="radio-group")
        p(class="radio-placeholder") 请选择 Profile

    fieldset
      legend 速度预设（Preset）
      div(id="presetOptions", class="radio-group")
        p(class="radio-placeholder") 请选择编码预设

    fieldset
      legend VMAF 目标
      div(class="vmaf-range")
        label(for="vmafMin") 最低值
        input(type="number", id="vmafMin", name="vmafMin", min="0", max="100", step="0.1", placeholder="例如 90")
        label(for="vmafMax") 最高值
        input(type="number", id="vmafMax", name="vmafMax", min="0", max="100", step="0.1", placeholder="例如 95")
      p(class="field-hint") 设置区间后系统会自动调整码率以靠近目标 VMAF（仅限码率模式）。

    fieldset
      legend 场景编码
      label(class="checkbox-option")
        input(type="checkbox", id="perScene", name="perScene")
        span 启用按场景切片编码（生成场景片段并合并输出）
      
      div(id="sceneThresholdGroup", class="hidden")
        label(for="sceneThreshold") 场景检测灵敏度
        input(type="number", id="sceneThreshold", name="sceneThreshold", 
              min="0.01", max="1", step="0.01", value="0.4")
        p(class="field-hint") 值越小检测越敏感（0.01-1.0），默认 0.4。快速剪辑视频建议 0.2-0.3，慢节奏内容建议 0.5-0.6。
      
      p(class="field-hint") 开启后将先用 FFmpeg 场景检测切片，每个片段独立调节码率以满足目标 VMAF，再合并生成最终文件及 HLS/DASH。
      label(for="sceneThresh") 场景检测阈值（0-1，建议 0.4）
      input(type="number", id="sceneThresh", name="sceneThresh", step="0.01", min="0.01", max="1", value="0.4", disabled)
      p(class="field-hint") 越大表示场景切换更敏感；仅在开启按场景编码时生效。

    fieldset
      legend 可选分析
      label(class="checkbox-option")
        input(type="checkbox", id="enableVmaf", name="enableVmaf")
        span 启用 VMAF 质量评估
      p(class="field-hint") 选择后将在任务完成后运行 VMAF 评估，可能增加额外耗时。
      label(for="vmafTimeout") VMAF 超时时间（秒）
      input(type="number", id="vmafTimeout", name="vmafTimeout", min="1", step="1", placeholder="例如 300")
      p(class="field-hint") 为 VMAF 分析设置一个超时时间，防止进程卡死。

    button(type="submit") 提交任务
  p#form-message

  script(type="application/json", id="codec-options-data").
    !{JSON.stringify(codecOptions)}
  script.
    const form = document.getElementById('job-form');
    const message = document.getElementById('form-message');
    const codecOptionsContainer = document.getElementById('codecOptions');
    const encoderOptionsContainer = document.getElementById('encoderOptions');
    const profileOptionsContainer = document.getElementById('profileOptions');
    const presetOptionsContainer = document.getElementById('presetOptions');
    const crfOptionsContainer = document.getElementById('crfOptions');
    const qualityModeContainer = document.getElementById('qualityModeOptions');
    const crfFieldset = document.getElementById('crfFieldset');
    const bitrateFieldset = document.getElementById('bitrateFieldset');
    const bitrateInput = document.getElementById('bitrateKbps');
    const vmafMinInput = document.getElementById('vmafMin');
    const vmafMaxInput = document.getElementById('vmafMax');
    const perSceneInput = document.getElementById('perScene');
    const sceneThresholdGroup = document.getElementById('sceneThresholdGroup');
    const sceneThresholdInput = document.getElementById('sceneThreshold');
    const sceneThreshInput = document.getElementById('sceneThresh');
    const enableVmafInput = document.getElementById('enableVmaf');
    const vmafTimeoutInput = document.getElementById('vmafTimeout');
    let currentQualityMode = 'crf';
    const codecOptionsData = JSON.parse(document.getElementById('codec-options-data').textContent);
    const codecMap = codecOptionsData.reduce((acc, codec) => {
      acc[codec.key] = codec;
      return acc;
    }, {});
    const STORAGE_KEY = 'jobForm.lastInput';

    function loadPersistedState() {
      if (!('localStorage' in window)) {
        return null;
      }
      try {
        const raw = window.localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          return null;
        }
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : null;
      } catch (error) {
        console.warn('无法读取历史输入', error);
        return null;
      }
    }

    function persistFormState(state) {
      if (!('localStorage' in window)) {
        return;
      }
      try {
        window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (error) {
        console.warn('无法保存历史输入', error);
      }
    }

    function fillRadioGroup(container, name, items, placeholder, selectedValue) {
      container.innerHTML = '';
      if (!items || items.length === 0) {
        const placeholderEl = document.createElement('p');
        placeholderEl.className = 'radio-placeholder';
        placeholderEl.textContent = placeholder;
        container.appendChild(placeholderEl);
        return null;
      }

      let selected = null;
      let requiredAssigned = false;
      let firstEnabledInput = null;
      items.forEach((item) => {
        const label = document.createElement('label');
        label.className = 'radio-option';
        if (item.disabled) {
          label.classList.add('disabled');
        }

        const input = document.createElement('input');
        input.type = 'radio';
        input.name = name;
        input.value = item.key;
        input.disabled = Boolean(item.disabled);
        if (!item.disabled && !requiredAssigned) {
          input.required = true;
          requiredAssigned = true;
        }

        if (!item.disabled && !firstEnabledInput) {
          firstEnabledInput = input;
        }

        const shouldCheck = !item.disabled && (
          selectedValue ? item.key === selectedValue : !selected
        );
        if (shouldCheck) {
          input.checked = true;
          selected = item.key;
        }

        const text = document.createElement('span');
        text.textContent = item.label;

        label.appendChild(input);
        label.appendChild(text);
        container.appendChild(label);
      });

      if (!selected && firstEnabledInput) {
        firstEnabledInput.checked = true;
        selected = firstEnabledInput.value;
      }

      return selected;
    }

    function getEncoderConfig(codecKey, encoderKey) {
      const codec = codecMap[codecKey];
      if (!codec) {
        return null;
      }
      return codec.encoders.find((item) => item.key === encoderKey) ?? null;
    }

    function determineCrfSelection(encoder, profileKey) {
      if (!encoder) {
        return null;
      }
      const profile = encoder.profiles?.find((item) => item.key === profileKey);
      if (!profile?.defaultCrf || !Array.isArray(encoder.crfOptions)) {
        return null;
      }
      return encoder.crfOptions.some((item) => item.key === profile.defaultCrf)
        ? profile.defaultCrf
        : null;
    }

    function determinePresetSelection(encoder, profileKey, presetKey) {
      if (!encoder) {
        return null;
      }
      if (presetKey && encoder.presets?.some((item) => item.key === presetKey)) {
        return presetKey;
      }
      const profile = encoder.profiles?.find((item) => item.key === profileKey);
      if (profile?.defaultPreset && encoder.presets?.some((item) => item.key === profile.defaultPreset)) {
        return profile.defaultPreset;
      }
      const firstPreset = encoder.presets?.find((item) => !item.disabled) ?? encoder.presets?.[0];
      return firstPreset?.key ?? null;
    }

    function setCrfGroupRequired(enabled) {
      const inputs = crfOptionsContainer.querySelectorAll('input[name="crf"]');
      inputs.forEach((input, index) => {
        input.required = enabled && index === 0;
      });
    }

    function renderEncoderDetails(codecKey, encoderKey, selected = {}) {
      const encoder = getEncoderConfig(codecKey, encoderKey);
      if (!encoder) {
        fillRadioGroup(profileOptionsContainer, 'profile', [], '请选择 Profile');
        fillRadioGroup(presetOptionsContainer, 'preset', [], '请选择编码预设');
        fillRadioGroup(crfOptionsContainer, 'crf', [], '请选择 CRF 值');
        return;
      }

      const profileSelection = fillRadioGroup(
        profileOptionsContainer,
        'profile',
        encoder.profiles,
        '请选择 Profile',
        selected.profile
      );

      const presetSelection = fillRadioGroup(
        presetOptionsContainer,
        'preset',
        encoder.presets,
        '请选择编码预设',
        determinePresetSelection(encoder, profileSelection, selected.preset)
      );

      const preferredCrf = selected.crf ?? determineCrfSelection(encoder, profileSelection);
      fillRadioGroup(
        crfOptionsContainer,
        'crf',
        encoder.crfOptions,
        '请选择 CRF 值',
        preferredCrf
      );
      setCrfGroupRequired(currentQualityMode === 'crf');
      return { profileSelection, presetSelection };
    }

    function updateEncoderOptions(codecKey, selected = {}) {
      const codec = codecMap[codecKey];
      const encoders = codec ? codec.encoders : [];
      const encoderSelection = fillRadioGroup(
        encoderOptionsContainer,
        'impl',
        encoders,
        '请选择编码器',
        selected.impl
      );
      if (encoderSelection) {
        renderEncoderDetails(codecKey, encoderSelection, {
          profile: selected.profile,
          preset: selected.preset,
          crf: selected.crf
        });
      } else {
        fillRadioGroup(profileOptionsContainer, 'profile', [], '请选择 Profile');
        fillRadioGroup(presetOptionsContainer, 'preset', [], '请选择编码预设');
        fillRadioGroup(crfOptionsContainer, 'crf', [], '请选择 CRF 值');
      }
    }

    function applyPersistedState(state) {
      if (!state || typeof state !== 'object') {
        return;
      }
      currentQualityMode = state.qualityMode === 'bitrate' ? 'bitrate' : 'crf';
      if (typeof state.inputPath === 'string') {
        form.elements.inputPath.value = state.inputPath;
      }
      if (typeof state.outputPath === 'string') {
        form.elements.outputPath.value = state.outputPath;
      }
      if (typeof state.perScene === 'boolean' && perSceneInput) {
        perSceneInput.checked = state.perScene;
      }
      if (sceneThreshInput) {
        if (Number.isFinite(state.sceneThreshold)) {
          sceneThreshInput.value = state.sceneThreshold;
        } else {
          sceneThreshInput.value = sceneThreshInput.defaultValue || '';
        }
      }
      if (qualityModeContainer) {
        const qualityInput = qualityModeContainer.querySelector(`input[name="qualityMode"][value="${currentQualityMode}"]`);
        if (qualityInput) {
          qualityInput.checked = true;
        }
      }
      if (state.codec) {
        const codecInput = codecOptionsContainer.querySelector(`input[name="codec"][value="${state.codec}"]`);
        if (codecInput) {
          codecInput.checked = true;
        }
      }
      let selectedCodec = state.codec;
      if (!selectedCodec || !codecMap[selectedCodec]) {
        selectedCodec = form.elements.codec?.value || null;
      }
      updateEncoderOptions(selectedCodec, state);
      if (state.scale) {
        const scaleInput = form.querySelector(`input[name="scale"][value="${state.scale}"]`);
        if (scaleInput) {
          scaleInput.checked = true;
        }
      }
      if (bitrateInput) {
        if (state.qualityMode === 'bitrate' && Number.isFinite(state.bitrateKbps)) {
          bitrateInput.value = state.bitrateKbps;
        } else {
          bitrateInput.value = '';
        }
      }
      if (enableVmafInput) {
        enableVmafInput.checked = Boolean(state.enableVmaf);
      }
      if (vmafMinInput) {
        vmafMinInput.value = Number.isFinite(state.vmafMin) ? state.vmafMin : '';
      }
      if (vmafMaxInput) {
        vmafMaxInput.value = Number.isFinite(state.vmafMax) ? state.vmafMax : '';
      }
      if (vmafTimeoutInput) {
        vmafTimeoutInput.value = Number.isFinite(state.vmafTimeout) ? state.vmafTimeout : '';
      }
    }

    codecOptionsContainer.addEventListener('change', (event) => {
      if (event.target.name !== 'codec') {
        return;
      }

      updateEncoderOptions(event.target.value);
    });

    encoderOptionsContainer.addEventListener('change', (event) => {
      if (event.target.name !== 'impl') {
        return;
      }

      const codecKey = form.elements.codec?.value;
      if (!codecKey) {
        return;
      }
      renderEncoderDetails(codecKey, event.target.value, {
        profile: form.elements.profile?.value,
        preset: form.elements.preset?.value,
        crf: form.elements.crf?.value
      });
    });

    profileOptionsContainer.addEventListener('change', (event) => {
      if (event.target.name !== 'profile') {
        return;
      }

      const codecKey = form.elements.codec?.value;
      const encoderKey = form.elements.impl?.value;
      if (!codecKey || !encoderKey) {
        return;
      }
      renderEncoderDetails(codecKey, encoderKey, {
        profile: event.target.value,
        preset: form.elements.preset?.value,
        crf: form.elements.crf?.value
      });
    });

    const persistedState = loadPersistedState();
    if (persistedState) {
      applyPersistedState(persistedState);
    } else {
      const defaultCodecInput = codecOptionsContainer.querySelector('input[name="codec"]:checked');
      if (defaultCodecInput) {
        updateEncoderOptions(defaultCodecInput.value);
      } else {
        updateEncoderOptions(null);
      }
    }

    function isPerSceneEnabled() {
      return Boolean(perSceneInput?.checked);
    }

    function updateSceneThresholdUI() {
      if (!sceneThreshInput) {
        return;
      }
      const enabled = isPerSceneEnabled();
      sceneThreshInput.disabled = !enabled;
      sceneThreshInput.required = enabled;
    }

    function updateQualityModeUI(mode) {
      currentQualityMode = mode;
      if (mode === 'bitrate') {
        crfFieldset.classList.add('hidden');
        bitrateFieldset.classList.remove('hidden');
        setCrfGroupRequired(false);
      } else {
        crfFieldset.classList.remove('hidden');
        bitrateFieldset.classList.add('hidden');
        setCrfGroupRequired(true);
      }
      if (bitrateInput) {
        bitrateInput.required = mode === 'bitrate';
        bitrateInput.disabled = mode !== 'bitrate';
      }
      const shouldEnableVmaf = mode === 'bitrate' || isPerSceneEnabled();
      [vmafMinInput, vmafMaxInput].forEach((input) => {
        if (input) {
          input.disabled = !shouldEnableVmaf;
        }
      });
    }

    qualityModeContainer.addEventListener('change', (event) => {
      if (event.target.name !== 'qualityMode') return;
      updateQualityModeUI(event.target.value);
    });

    if (perSceneInput) {
      perSceneInput.addEventListener('change', () => {
        updateSceneThresholdUI();
        updateQualityModeUI(currentQualityMode);
        // 显示或隐藏 sceneThreshold 输入框
        if (sceneThresholdGroup && sceneThresholdInput) {
          if (perSceneInput.checked) {
            sceneThresholdGroup.classList.remove('hidden');
          } else {
            sceneThresholdGroup.classList.add('hidden');
          }
        }
      });
    }

    updateSceneThresholdUI();
    updateQualityModeUI(currentQualityMode);

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      message.textContent = '正在提交...';
      const formData = new FormData(form);
      const codec = formData.get('codec');
      const impl = formData.get('impl');
      const profile = formData.get('profile');
      const preset = formData.get('preset');
      const crf = formData.get('crf');
      const scale = formData.get('scale');
      const qualityMode = formData.get('qualityMode') || 'crf';
      const bitrateValue = formData.get('bitrateKbps');
      const bitrateNumeric = Number(bitrateValue);
      if (!codec || !impl || !profile || !preset || !scale) {
        message.textContent = '请输入完整的输入、输出与编码选项';
        return;
      }
      if (qualityMode === 'crf' && !crf) {
        message.textContent = '请选择 CRF 值';
        return;
      }
      if (qualityMode === 'bitrate' && !bitrateValue) {
        message.textContent = '请输入目标码率';
        return;
      }
      const vmafMin = parseFloat(formData.get('vmafMin'));
      const vmafMax = parseFloat(formData.get('vmafMax'));
      const hasVmafRange = Number.isFinite(vmafMin) && Number.isFinite(vmafMax);
      if (hasVmafRange && vmafMin > vmafMax) {
        message.textContent = 'VMAF 最低值不能大于最高值';
        return;
      }
      const presetKey = `${codec}:${impl}:${profile}:${preset}:${crf || 'bitrate'}`;
      const perScene = perSceneInput?.checked ?? false;
      const sceneThreshold = perScene && sceneThresholdInput ? parseFloat(formData.get('sceneThreshold')) : null;
      if (perScene && !hasVmafRange) {
        message.textContent = '场景编码模式需要设置 VMAF 最低值与最高值';
        return;
      }
      if (perScene && sceneThreshold !== null && (sceneThreshold < 0.01 || sceneThreshold > 1)) {
        message.textContent = '场景检测灵敏度必须在 0.01-1.0 范围内';
        return;
      }
      const enableVmaf = formData.get('enableVmaf') === 'on' || hasVmafRange || perScene;
      const vmafTimeout = parseInt(formData.get('vmafTimeout'), 10);

      const payload = {
        inputPath: formData.get('inputPath'),
        outputPath: formData.get('outputPath'),
        codec,
        impl,
        params: {
          presetKey,
          profile,
          preset,
          crf,
          scale,
          qualityMode,
          bitrateKbps: qualityMode === 'bitrate' ? bitrateNumeric : null,
          enableVmaf,
          vmafMin: hasVmafRange ? vmafMin : null,
          vmafMax: hasVmafRange ? vmafMax : null,
          perScene,
          sceneThreshold: perScene ? (sceneThreshold || 0.4) : null
        }
      };
      persistFormState({
        inputPath: formData.get('inputPath') || '',
        outputPath: formData.get('outputPath') || '',
        codec,
        impl,
        profile,
        preset,
        crf: qualityMode === 'crf' ? crf : null,
        scale,
        qualityMode,
        bitrateKbps: qualityMode === 'bitrate' && Number.isFinite(bitrateNumeric) ? bitrateNumeric : null,
        enableVmaf,
        vmafMin: hasVmafRange ? vmafMin : null,
        vmafMax: hasVmafRange ? vmafMax : null,
        perScene,
        sceneThreshold: perScene && Number.isFinite(sceneThreshold) ? sceneThreshold : null,
        vmafTimeout: Number.isFinite(vmafTimeout) ? vmafTimeout : null
      });
      const res = await fetch('/api/jobs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (res.ok) {
        const job = await res.json();
        window.location.href = `/jobs/${job.id}`;
      } else {
        const error = await res.json().catch(() => ({ error: '提交失败' }));
        message.textContent = error.error || '提交失败';
      }
    });
